<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Newly Optimized RF24Network Layer: RF24Network Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Newly Optimized RF24Network Layer
   &#160;<span id="projectnumber">1.0.16</span>
   </div>
   <div id="projectbrief">2020 - Optimized RF24 Network Layer for NRF24L01 radios</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="classRF24Network-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RF24Network Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="RF24Network_8h_source.html">RF24Network.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Primary Interface</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are the main methods you need to operate the network </p>
</div></td></tr>
<tr class="memitem:a814229a5a4e8e30f88a4bdce05807e50"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a814229a5a4e8e30f88a4bdce05807e50">RF24Network</a> (RF24 &amp;_radio)</td></tr>
<tr class="separator:a814229a5a4e8e30f88a4bdce05807e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6a74b55514a26e95e20eaa6a093a0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#aad6a74b55514a26e95e20eaa6a093a0b">begin</a> (uint16_t _node_address)</td></tr>
<tr class="separator:aad6a74b55514a26e95e20eaa6a093a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59983f89b09d17d7d9b0581f658a41c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#ad59983f89b09d17d7d9b0581f658a41c">update</a> (void)</td></tr>
<tr class="separator:ad59983f89b09d17d7d9b0581f658a41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e111e70bb7b95d885983ce92c89159e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a0e111e70bb7b95d885983ce92c89159e">available</a> (void)</td></tr>
<tr class="separator:a0e111e70bb7b95d885983ce92c89159e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac371cf064c23d181c5dd56f528bd08"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#abac371cf064c23d181c5dd56f528bd08">peek</a> (<a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;header)</td></tr>
<tr class="separator:abac371cf064c23d181c5dd56f528bd08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b612ccb5e1fcc547b7984f9cff37a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a11b612ccb5e1fcc547b7984f9cff37a5">peek</a> (<a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;header, void *message, uint16_t maxlen=<a class="el" href="RF24Network__config_8h.html#a6303f7392a2d06be5a121c54278d561b">MAX_PAYLOAD_SIZE</a>)</td></tr>
<tr class="separator:a11b612ccb5e1fcc547b7984f9cff37a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6630ab36b8a42cc376c925721f39188d"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a6630ab36b8a42cc376c925721f39188d">read</a> (<a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;header, void *message, uint16_t maxlen=<a class="el" href="RF24Network__config_8h.html#a6303f7392a2d06be5a121c54278d561b">MAX_PAYLOAD_SIZE</a>)</td></tr>
<tr class="separator:a6630ab36b8a42cc376c925721f39188d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e9571bb3d2c20d00955b8f5c15b541"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#ac8e9571bb3d2c20d00955b8f5c15b541">write</a> (<a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;header, const void *message, uint16_t len)</td></tr>
<tr class="separator:ac8e9571bb3d2c20d00955b8f5c15b541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Advanced Operation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>For advanced operation of the network </p>
</div></td></tr>
<tr class="memitem:acb84d7556df00c933208ecf44b227a4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#acb84d7556df00c933208ecf44b227a4f">failures</a> (uint32_t *_fails, uint32_t *_ok)</td></tr>
<tr class="separator:acb84d7556df00c933208ecf44b227a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a66907061c54ee1fea6ea7f78d6827"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a96a66907061c54ee1fea6ea7f78d6827">multicast</a> (<a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;header, const void *message, uint16_t len, uint8_t level=7)</td></tr>
<tr class="separator:a96a66907061c54ee1fea6ea7f78d6827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d99643014071fef706c0320c8011648"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a3d99643014071fef706c0320c8011648">write</a> (<a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;header, const void *message, uint16_t len, uint16_t writeDirect)</td></tr>
<tr class="separator:a3d99643014071fef706c0320c8011648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3e7809ffc7ff48579811d2e063142a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#acc3e7809ffc7ff48579811d2e063142a">sleepNode</a> (unsigned int cycles, int interruptPin, uint8_t INTERRUPT_MODE=0)</td></tr>
<tr class="separator:acc3e7809ffc7ff48579811d2e063142a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6919435695051d522dfcce4e8395f5e"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#aa6919435695051d522dfcce4e8395f5e">parent</a> () const</td></tr>
<tr class="separator:aa6919435695051d522dfcce4e8395f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a11edb3860f4a0e3808bccad36a5dc"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#aa4a11edb3860f4a0e3808bccad36a5dc">addressOfPipe</a> (uint16_t node, uint8_t pipeNo)</td></tr>
<tr class="separator:aa4a11edb3860f4a0e3808bccad36a5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41da035bd7f469ea4364a06ab4efd1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#ab41da035bd7f469ea4364a06ab4efd1b">is_valid_address</a> (uint16_t node)</td></tr>
<tr class="separator:ab41da035bd7f469ea4364a06ab4efd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Deprecated</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Maintained for backwards compatibility </p>
</div></td></tr>
<tr class="memitem:abf0da46b2e78b2010171c9f20cba8bae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#abf0da46b2e78b2010171c9f20cba8bae">begin</a> (uint8_t _channel, uint16_t _node_address)</td></tr>
<tr class="separator:abf0da46b2e78b2010171c9f20cba8bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Advanced Configuration</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpc70ec5b31b31ecef0efd3ea40e33909f"></a>For advanced configuration of the network </p>
</td></tr>
<tr class="memitem:add7408ca2b2f9ab15331ba77a747f7bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#add7408ca2b2f9ab15331ba77a747f7bb">multicastRelay</a></td></tr>
<tr class="separator:add7408ca2b2f9ab15331ba77a747f7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8838b42717e7c9da37213b020db1f88c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a8838b42717e7c9da37213b020db1f88c">txTimeout</a></td></tr>
<tr class="memdesc:a8838b42717e7c9da37213b020db1f88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Network timeout value.  <a href="classRF24Network.html#a8838b42717e7c9da37213b020db1f88c">More...</a><br /></td></tr>
<tr class="separator:a8838b42717e7c9da37213b020db1f88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657fd03730b6c9084cc440b4fe0177c3"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a657fd03730b6c9084cc440b4fe0177c3">routeTimeout</a></td></tr>
<tr class="memdesc:a657fd03730b6c9084cc440b4fe0177c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timeout for routed payloads.  <a href="classRF24Network.html#a657fd03730b6c9084cc440b4fe0177c3">More...</a><br /></td></tr>
<tr class="separator:a657fd03730b6c9084cc440b4fe0177c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb7c61eee75d708a4ba20bb1caec54f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a4fb7c61eee75d708a4ba20bb1caec54f">multicastLevel</a> (uint8_t level)</td></tr>
<tr class="separator:a4fb7c61eee75d708a4ba20bb1caec54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb09129760ac9b171833af3055b2b6f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#acb09129760ac9b171833af3055b2b6f5">setup_watchdog</a> (uint8_t prescalar)</td></tr>
<tr class="separator:acb09129760ac9b171833af3055b2b6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">External Applications/Systems</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpa44565bba507e198594663bd302b9223"></a>Interface for External Applications and Systems ( RF24Mesh, RF24Ethernet ) </p>
</td></tr>
<tr class="memitem:aa06f1fdd0fd986d427c2c5193b47b212"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#aa06f1fdd0fd986d427c2c5193b47b212">frame_buffer</a> [<a class="el" href="RF24Network_8h.html#ad15d35a0d29a9dbf9324e3859ce3b008">MAX_FRAME_SIZE</a>]</td></tr>
<tr class="memdesc:aa06f1fdd0fd986d427c2c5193b47b212"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw system frame buffer.  <a href="classRF24Network.html#aa06f1fdd0fd986d427c2c5193b47b212">More...</a><br /></td></tr>
<tr class="separator:aa06f1fdd0fd986d427c2c5193b47b212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab387a2137dc1b62c1bf5cc783e34e2c0"><td class="memItemLeft" align="right" valign="top">std::queue&lt; <a class="el" href="structRF24NetworkFrame.html">RF24NetworkFrame</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#ab387a2137dc1b62c1bf5cc783e34e2c0">external_queue</a></td></tr>
<tr class="separator:ab387a2137dc1b62c1bf5cc783e34e2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c994c5fdcb2173b187c52b641aaeae0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRF24NetworkFrame.html">RF24NetworkFrame</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a1c994c5fdcb2173b187c52b641aaeae0">frag_ptr</a></td></tr>
<tr class="separator:a1c994c5fdcb2173b187c52b641aaeae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6b1d5c0fa3d982425f7a1f4fb48d13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#afb6b1d5c0fa3d982425f7a1f4fb48d13">returnSysMsgs</a></td></tr>
<tr class="separator:afb6b1d5c0fa3d982425f7a1f4fb48d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476806538919b167465181ab872e0cad"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a476806538919b167465181ab872e0cad">networkFlags</a></td></tr>
<tr class="separator:a476806538919b167465181ab872e0cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b89e48e46eebb615b2ef152f057aca7"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a5b89e48e46eebb615b2ef152f057aca7">_multicast_level</a></td></tr>
<tr class="separator:a5b89e48e46eebb615b2ef152f057aca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17017b584633bb969d004c4c43ca5c82"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24Network.html#a17017b584633bb969d004c4c43ca5c82">node_address</a></td></tr>
<tr class="separator:a17017b584633bb969d004c4c43ca5c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>2014-2021 - Optimized Network Layer for RF24 Radios</p>
<p>This class implements an OSI Network Layer using nRF24L01(+) radios driven by RF24 library. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Network_Ping_8ino-example.html#_a0">Network_Ping.ino</a>, <a class="el" href="Network_Ping_Sleep_8ino-example.html#_a0">Network_Ping_Sleep.ino</a>, <a class="el" href="Network_Priority_RX_8ino-example.html#_a0">Network_Priority_RX.ino</a>, <a class="el" href="Network_Priority_TX_8ino-example.html#_a0">Network_Priority_TX.ino</a>, <a class="el" href="helloworld_rx_8ino-example.html#_a0">helloworld_rx.ino</a>, <a class="el" href="helloworld_rx_advanced_8ino-example.html#_a0">helloworld_rx_advanced.ino</a>, <a class="el" href="helloworld_tx_8ino-example.html#_a0">helloworld_tx.ino</a>, and <a class="el" href="helloworld_tx_advanced_8ino-example.html#_a0">helloworld_tx_advanced.ino</a>.</dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a814229a5a4e8e30f88a4bdce05807e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a814229a5a4e8e30f88a4bdce05807e50">&#9670;&nbsp;</a></span>RF24Network()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RF24Network::RF24Network </td>
          <td>(</td>
          <td class="paramtype">RF24 &amp;&#160;</td>
          <td class="paramname"><em>_radio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct the network</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_radio</td><td>The underlying radio driver instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aad6a74b55514a26e95e20eaa6a093a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6a74b55514a26e95e20eaa6a093a0b">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RF24Network::begin </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>_node_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Bring up the network using the current radio frequency/channel. Calling begin brings up the network, and configures the address, which designates the location of the node within <a href="md_docs_tuning.html">RF24Network topology</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Node addresses are specified in Octal format, see <a href="md_docs_addressing.html">RF24Network Addressing</a> for more information. The address <code>04444</code> is reserved for RF24Mesh usage (when a mesh node is connecting to the network). </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Be sure to first call <code>RF24::begin()</code> to initialize the radio properly.</dd></dl>
<p><b>Example 1:</b> Begin on current radio channel with address 0 (master node) </p><div class="fragment"><div class="line">network.begin(00); </div>
</div><!-- fragment --><p> <b>Example 2:</b> Begin with address 01 (child of master) </p><div class="fragment"><div class="line">network.begin(01); </div>
</div><!-- fragment --><p> <b>Example 3:</b> Begin with address 011 (child of 01, grandchild of master) </p><div class="fragment"><div class="line">network.begin(011); </div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRF24Network.html#abf0da46b2e78b2010171c9f20cba8bae">begin(uint8_t _channel, uint16_t _node_address)</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_node_address</td><td>The logical address of this node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad59983f89b09d17d7d9b0581f658a41c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59983f89b09d17d7d9b0581f658a41c">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24Network::update </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Main layer loop</p>
<p>This function must be called regularly to keep the layer going. This is where payloads are re-routed, received, and all the action happens.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the <a class="el" href="structRF24NetworkHeader.html#ac99ab14e561670f4445d1fea7775e2db">RF24NetworkHeader::type</a> of the last received payload. </dd></dl>

</div>
</div>
<a id="a0e111e70bb7b95d885983ce92c89159e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e111e70bb7b95d885983ce92c89159e">&#9670;&nbsp;</a></span>available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24Network::available </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test whether there is a message available for this node</p>
<dl class="section return"><dt>Returns</dt><dd>Whether there is a message available for this node </dd></dl>

</div>
</div>
<a id="abac371cf064c23d181c5dd56f528bd08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac371cf064c23d181c5dd56f528bd08">&#9670;&nbsp;</a></span>peek() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t RF24Network::peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>header</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the next available header</p>
<p>Reads the next available header without advancing to the next incoming message. Useful for doing a switch on the message type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">header</td><td>The <a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> (envelope) of the next message. If there is no message available, the referenced <code>header</code> object is not touched </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the next available message in the queue. </dd></dl>

</div>
</div>
<a id="a11b612ccb5e1fcc547b7984f9cff37a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b612ccb5e1fcc547b7984f9cff37a5">&#9670;&nbsp;</a></span>peek() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24Network::peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>maxlen</em> = <code><a class="el" href="RF24Network__config_8h.html#a6303f7392a2d06be5a121c54278d561b">MAX_PAYLOAD_SIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the next available payload</p>
<p>Reads the next available payload without advancing to the next incoming message. Useful for doing a transparent packet manipulation layer on top of <a class="el" href="classRF24Network.html">RF24Network</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">header</td><td>The <a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> (envelope) of this message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message</td><td>Pointer to memory where the message should be placed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxlen</td><td>Amount of bytes to copy to <code>message</code> . If this parameter is left unspecified, the entire length of the message is fetched. Hint: Use peek(RF24NetworkHeader) to get the length of next available message in the queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6630ab36b8a42cc376c925721f39188d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6630ab36b8a42cc376c925721f39188d">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t RF24Network::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>maxlen</em> = <code><a class="el" href="RF24Network__config_8h.html#a6303f7392a2d06be5a121c54278d561b">MAX_PAYLOAD_SIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a message </p><dl class="section note"><dt>Note</dt><dd>This function assumes there is a frame in the queue. <div class="fragment"><div class="line"><span class="keywordflow">while</span> (network.available()) {</div>
<div class="line">  <a class="code" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> header;</div>
<div class="line">  uint32_t time;</div>
<div class="line">  uint16_t msg_size = network.peek(header);</div>
<div class="line">  <span class="keywordflow">if</span> (header.<a class="code" href="structRF24NetworkHeader.html#ac99ab14e561670f4445d1fea7775e2db">type</a> == <span class="charliteral">&#39;T&#39;</span>) {</div>
<div class="line">    network.read(header, &amp;time, <span class="keyword">sizeof</span>(time));</div>
<div class="line">    Serial.print(<span class="stringliteral">&quot;Got time: &quot;</span>);</div>
<div class="line">    Serial.println(time);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="astructRF24NetworkHeader_html"><div class="ttname"><a href="structRF24NetworkHeader.html">RF24NetworkHeader</a></div><div class="ttdef"><b>Definition:</b> RF24Network.h:226</div></div>
<div class="ttc" id="astructRF24NetworkHeader_html_ac99ab14e561670f4445d1fea7775e2db"><div class="ttname"><a href="structRF24NetworkHeader.html#ac99ab14e561670f4445d1fea7775e2db">RF24NetworkHeader::type</a></div><div class="ttdeci">unsigned char type</div><div class="ttdef"><b>Definition:</b> RF24Network.h:243</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">header</td><td>The <a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> (envelope) of this message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message</td><td>Pointer to memory where the message should be placed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxlen</td><td>The largest message size which can be held in <code>message</code> . If this parameter is left unspecified, the entire length of the message is fetched. Hint: Use <a class="el" href="classRF24Network.html#abac371cf064c23d181c5dd56f528bd08">peek(RF24NetworkHeader &amp;)</a> to get the length of next available message in the queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of bytes copied into <code>message</code> </dd></dl>

</div>
</div>
<a id="ac8e9571bb3d2c20d00955b8f5c15b541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e9571bb3d2c20d00955b8f5c15b541">&#9670;&nbsp;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24Network::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a message</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classRF24Network.html">RF24Network</a> now supports fragmentation for very long messages, send as normal. Fragmentation may need to be enabled or configured by editing the <a class="el" href="RF24Network__config_8h.html">RF24Network_config.h</a> file. Default max payload size is 120 bytes.</dd></dl>
<div class="fragment"><div class="line">uint32_t time = millis();</div>
<div class="line">uint16_t to = 00; <span class="comment">// Send to master</span></div>
<div class="line"><a class="code" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> header(to, <span class="charliteral">&#39;T&#39;</span>); <span class="comment">// Send header type &#39;T&#39;</span></div>
<div class="line">network.write(header, &amp;time, <span class="keyword">sizeof</span>(time));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">header</td><td>The header (envelope) of this message. The critical thing to fill in is the <code>to_node</code> field so we know where to send the message. It is then updated with the details of the actual header sent. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">message</td><td>Pointer to memory where the message is located </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">len</td><td>The size of the message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the message was successfully received </dd></dl>

</div>
</div>
<a id="a4fb7c61eee75d708a4ba20bb1caec54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb7c61eee75d708a4ba20bb1caec54f">&#9670;&nbsp;</a></span>multicastLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24Network::multicastLevel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>By default, multicast addresses are divided into 5 network levels:</p><ul>
<li>The master node is the only node on level 0 (the lowest level)</li>
<li>Nodes 01-05 (level 1) share a multicast address</li>
<li>Nodes 0n1-0n5 (level 2) share a multicast address</li>
<li>Nodes 0n11-0n55 (level 3) share a multicast address</li>
<li>Nodes 0n111-0n555 (level 4) share a multicast address</li>
</ul>
<p>Notice "n" (used in the list above) stands for an octal digit in range [0, 5]</p>
<p>This optional function is used to override the default level set when a node's logical address changes, and it can be used to create custom multicast groups that all share a single address. </p><dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="classRF24Network.html#add7408ca2b2f9ab15331ba77a747f7bb">multicastRelay</a></li>
<li><a class="el" href="classRF24Network.html#a96a66907061c54ee1fea6ea7f78d6827">multicast()</a></li>
<li><a href="http://github.com/nRF24/RF24Network/blob/master/images/topologyImage.jpg">The topology image</a> </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>Levels 0 to 4 are available. All nodes at the same level will receive the same messages if in range. Messages will be routed in order of level, low to high, by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb09129760ac9b171833af3055b2b6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb09129760ac9b171833af3055b2b6f5">&#9670;&nbsp;</a></span>setup_watchdog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24Network::setup_watchdog </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>prescalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set up the watchdog timer for sleep mode using the number 0 through 10 to represent the following time periods:<br  />
 wdt_16ms = 0, wdt_32ms, wdt_64ms, wdt_128ms, wdt_250ms, wdt_500ms, wdt_1s, wdt_2s, wdt_4s, wdt_8s </p><div class="fragment"><div class="line"><a class="code" href="classRF24Network.html#acb09129760ac9b171833af3055b2b6f5">setup_watchdog</a>(7);   <span class="comment">// Sets the WDT to trigger every second</span></div>
<div class="ttc" id="aclassRF24Network_html_acb09129760ac9b171833af3055b2b6f5"><div class="ttname"><a href="classRF24Network.html#acb09129760ac9b171833af3055b2b6f5">RF24Network::setup_watchdog</a></div><div class="ttdeci">void setup_watchdog(uint8_t prescalar)</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prescalar</td><td>The WDT prescaler to define how often the node will wake up. When defining sleep mode cycles, this time period is 1 cycle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb84d7556df00c933208ecf44b227a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb84d7556df00c933208ecf44b227a4f">&#9670;&nbsp;</a></span>failures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24Network::failures </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>_fails</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>_ok</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of failures and successes for all transmitted payloads, routed or sent directly </p><dl class="section note"><dt>Note</dt><dd>This needs to be enabled via <code>#define ENABLE_NETWORK_STATS</code> in <a class="el" href="RF24Network__config_8h.html">RF24Network_config.h</a></dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> fails, success;</div>
<div class="line">network.failures(&amp;fails, &amp;success);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a96a66907061c54ee1fea6ea7f78d6827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a66907061c54ee1fea6ea7f78d6827">&#9670;&nbsp;</a></span>multicast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24Network::multicast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>level</em> = <code>7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a multicast message to multiple nodes at once Allows messages to be rapidly broadcast through the network</p>
<p>Multicasting is arranged in levels, with all nodes on the same level listening to the same address Levels are assigned by network level ie: nodes 01-05: Level 1, nodes 011-055: Level 2 </p><dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="classRF24Network.html#a4fb7c61eee75d708a4ba20bb1caec54f">multicastLevel()</a></li>
<li><a class="el" href="classRF24Network.html#add7408ca2b2f9ab15331ba77a747f7bb">multicastRelay</a> </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header</td><td>reference to the <a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> object used for this <code>message</code> </td></tr>
    <tr><td class="paramname">message</td><td>Pointer to memory where the message is located </td></tr>
    <tr><td class="paramname">len</td><td>The size of the message </td></tr>
    <tr><td class="paramname">level</td><td>Multicast level to broadcast to. If this parameter is unspecified, then the node's current <a class="el" href="classRF24Network.html#a4fb7c61eee75d708a4ba20bb1caec54f">multicastLevel()</a> is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the message was successfully sent </dd></dl>

</div>
</div>
<a id="a3d99643014071fef706c0320c8011648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d99643014071fef706c0320c8011648">&#9670;&nbsp;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24Network::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>writeDirect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a direct (unicast) payload. This allows routing or sending messages outside of the usual routing paths. The same as write, but a physical address is specified as the last option. The payload will be written to the physical address, and routed as necessary by the recipient. </p>

</div>
</div>
<a id="acc3e7809ffc7ff48579811d2e063142a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3e7809ffc7ff48579811d2e063142a">&#9670;&nbsp;</a></span>sleepNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24Network::sleepNode </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cycles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interruptPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>INTERRUPT_MODE</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sleep this node - For AVR devices only </p><dl class="section note"><dt>Note</dt><dd>NEW - Nodes can now be slept while the radio is not actively transmitting. This must be manually enabled by uncommenting the <code>#define ENABLE_SLEEP_MODE</code> in <a class="el" href="RF24Network__config_8h.html">RF24Network_config.h</a> </dd>
<dd>
The watchdog timer should be configured in the sketch's <code>setup()</code> if using sleep mode. This function will sleep the node, with the radio still active in receive mode. See <a class="el" href="classRF24Network.html#acb09129760ac9b171833af3055b2b6f5">setup_watchdog()</a>.</dd></dl>
<p>The node can be awoken in two ways, both of which can be enabled simultaneously:</p><ol type="1">
<li>An interrupt - usually triggered by the radio receiving a payload. Must use pin 2 (interrupt 0) or 3 (interrupt 1) on Uno, Nano, etc.</li>
<li>The watchdog timer waking the MCU after a designated period of time, can also be used instead of delays to control transmission intervals.</li>
</ol>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(!network.available())</div>
<div class="line">    network.sleepNode(1, 0); <span class="comment">// Sleep the node for 1 second or a payload is received</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Other options:</span></div>
<div class="line">network.sleepNode(0, 0);     <span class="comment">// Sleep this node for the designated time period, or a payload is received.</span></div>
<div class="line">network.sleepNode(1, 255);   <span class="comment">// Sleep this node for 1 cycle. Do not wake up until then, even if a payload is received ( no interrupt )</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cycles</td><td>The node will sleep in cycles of 1s. Using 2 will sleep 2 WDT cycles, 3 sleeps 3WDT cycles... </td></tr>
    <tr><td class="paramname">interruptPin</td><td>The interrupt number to use (0, 1) for pins 2 and 3 on Uno &amp; Nano. More available on Mega etc. Setting this parameter to 255 will disable interrupt wake-ups. </td></tr>
    <tr><td class="paramname">INTERRUPT_MODE</td><td>an identifying number to indicate what type of state for which the <code>interrupt_pin</code> will be used to wake up the radio. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter"><code>INTERRUPT_MODE</code>   </th><th class="markdownTableHeadCenter">type of state    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">0   </td><td class="markdownTableBodyCenter">LOW    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">1   </td><td class="markdownTableBodyCenter">RISING    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">2   </td><td class="markdownTableBodyCenter">FALLING    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">3   </td><td class="markdownTableBodyCenter">CHANGE   </td></tr>
</table>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if sleepNode completed normally, after the specified number of cycles. False if sleep was interrupted </dd></dl>

</div>
</div>
<a id="aa6919435695051d522dfcce4e8395f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6919435695051d522dfcce4e8395f5e">&#9670;&nbsp;</a></span>parent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t RF24Network::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This node's parent address</p>
<dl class="section return"><dt>Returns</dt><dd>This node's parent address, or 65535 (-1 when casted to a signed int16_t) if this is the master node. </dd></dl>

</div>
</div>
<a id="aa4a11edb3860f4a0e3808bccad36a5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a11edb3860f4a0e3808bccad36a5dc">&#9670;&nbsp;</a></span>addressOfPipe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t RF24Network::addressOfPipe </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pipeNo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provided a node address and a pipe number, will return the <a class="el" href="classRF24Network.html">RF24Network</a> address of that child pipe for that node. </p>

</div>
</div>
<a id="ab41da035bd7f469ea4364a06ab4efd1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41da035bd7f469ea4364a06ab4efd1b">&#9670;&nbsp;</a></span>is_valid_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24Network::is_valid_address </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Validate a network address as a proper logical address </p><dl class="section note"><dt>Note</dt><dd>Addresses are specified in octal form, ie 011, 034. Review <a href="md_docs_addressing.html">RF24Nettwork addressing</a> for more information. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The specified logical address of a network node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified <code>node</code> address is a valid network address, otherwise false. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function will validate an improper address of <code>0100</code> as it is the reserved <a class="el" href="RF24Network__config_8h.html#a9384801ca5f2283143ab651994179e8c">NETWORK_MULTICAST_ADDRESS</a> used for multicasted messages. </dd></dl>

</div>
</div>
<a id="abf0da46b2e78b2010171c9f20cba8bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0da46b2e78b2010171c9f20cba8bae">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24Network::begin </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>_channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>_node_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bring up the network on a specific radio frequency/channel. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Use <code>RF24::setChannel()</code> to configure the radio channel. Use <a class="el" href="classRF24Network.html#aad6a74b55514a26e95e20eaa6a093a0b">RF24Network::begin(uint16_t _node_address)</a> to set the node address.</dd></dl>
<p><b>Example 1:</b> Begin on channel 90 with address 0 (master node) </p><div class="fragment"><div class="line">network.begin(90, 0);</div>
</div><!-- fragment --><p> <b>Example 2:</b> Begin on channel 90 with address 01 (child of master) </p><div class="fragment"><div class="line">network.begin(90, 01);</div>
</div><!-- fragment --><p> <b>Example 3:</b> Begin on channel 90 with address 011 (child of 01, grandchild of master) </p><div class="fragment"><div class="line">network.begin(90, 011);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_channel</td><td>The RF channel to operate on. </td></tr>
    <tr><td class="paramname">_node_address</td><td>The logical address of this node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="add7408ca2b2f9ab15331ba77a747f7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7408ca2b2f9ab15331ba77a747f7bb">&#9670;&nbsp;</a></span>multicastRelay</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24Network::multicastRelay</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enabling this will allow this node to automatically forward received multicast frames to the next highest multicast level. Forwarded frames will also be enqueued on the forwarding node as a received frame.</p>
<p>This is disabled by default. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRF24Network.html#a4fb7c61eee75d708a4ba20bb1caec54f">multicastLevel()</a> </dd></dl>

</div>
</div>
<a id="a8838b42717e7c9da37213b020db1f88c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8838b42717e7c9da37213b020db1f88c">&#9670;&nbsp;</a></span>txTimeout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t RF24Network::txTimeout</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Network timeout value. </p>
<dl class="section note"><dt>Note</dt><dd>This value is automatically assigned based on the node address to reduce errors and increase throughput of the network.</dd></dl>
<p>Sets the timeout period for individual payloads in milliseconds at staggered intervals. Payloads will be retried automatically until success or timeout. Set to 0 to use the normal auto retry period defined by <code>radio.setRetries()</code>. </p>

</div>
</div>
<a id="a657fd03730b6c9084cc440b4fe0177c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657fd03730b6c9084cc440b4fe0177c3">&#9670;&nbsp;</a></span>routeTimeout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t RF24Network::routeTimeout</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timeout for routed payloads. </p>
<p>This only affects payloads that are routed through one or more nodes. This specifies how long to wait for an ack from across the network. Radios sending directly to their parent or children nodes do not utilize this value. </p>

</div>
</div>
<a id="aa06f1fdd0fd986d427c2c5193b47b212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06f1fdd0fd986d427c2c5193b47b212">&#9670;&nbsp;</a></span>frame_buffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24Network::frame_buffer[<a class="el" href="RF24Network_8h.html#ad15d35a0d29a9dbf9324e3859ce3b008">MAX_FRAME_SIZE</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The raw system frame buffer. </p>
<p>This member can be accessed to retrieve the latest received data just after it is enqueued. This buffer is also used for outgoing data. </p><dl class="section warning"><dt>Warning</dt><dd>Conditionally, this buffer may only contain fragments of a message (either outgoing or incoming). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The first 8 bytes of this buffer is latest handled frame's <a class="el" href="structRF24NetworkHeader.html">RF24NetworkHeader</a> data. </dd></dl>

</div>
</div>
<a id="ab387a2137dc1b62c1bf5cc783e34e2c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab387a2137dc1b62c1bf5cc783e34e2c0">&#9670;&nbsp;</a></span>external_queue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::queue&lt;<a class="el" href="structRF24NetworkFrame.html">RF24NetworkFrame</a>&gt; RF24Network::external_queue</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Linux platforms only</b></p>
<p>Data with a header type of <a class="el" href="group__DEFINED__TYPES.html#gac6bbd2772e776d10ca7c5f3c7eddf982">EXTERNAL_DATA_TYPE</a> will be loaded into a separate queue. The data can be accessed as follows: </p><div class="fragment"><div class="line"><a class="code" href="structRF24NetworkFrame.html">RF24NetworkFrame</a> f;</div>
<div class="line"><span class="keywordflow">while</span>(network.external_queue.size() &gt; 0) {</div>
<div class="line">  f = network.external_queue.front();</div>
<div class="line">  uint16_t dataSize = f.<a class="code" href="structRF24NetworkFrame.html#a6d44701fc5ef58ed6f674fde132bedff">message_size</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// read the frame message buffer</span></div>
<div class="line">  memcpy(&amp;myBuffer, &amp;f.<a class="code" href="structRF24NetworkFrame.html#a2ca805d90caa7aef8005fafd2c55fbc6">message_buffer</a>, dataSize);</div>
<div class="line">  network.external_queue.pop();</div>
<div class="line">}</div>
<div class="ttc" id="astructRF24NetworkFrame_html"><div class="ttname"><a href="structRF24NetworkFrame.html">RF24NetworkFrame</a></div><div class="ttdef"><b>Definition:</b> RF24Network.h:310</div></div>
<div class="ttc" id="astructRF24NetworkFrame_html_a2ca805d90caa7aef8005fafd2c55fbc6"><div class="ttname"><a href="structRF24NetworkFrame.html#a2ca805d90caa7aef8005fafd2c55fbc6">RF24NetworkFrame::message_buffer</a></div><div class="ttdeci">uint8_t * message_buffer</div><div class="ttdef"><b>Definition:</b> RF24Network.h:324</div></div>
<div class="ttc" id="astructRF24NetworkFrame_html_a6d44701fc5ef58ed6f674fde132bedff"><div class="ttname"><a href="structRF24NetworkFrame.html#a6d44701fc5ef58ed6f674fde132bedff">RF24NetworkFrame::message_size</a></div><div class="ttdeci">uint16_t message_size</div><div class="ttdef"><b>Definition:</b> RF24Network.h:315</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1c994c5fdcb2173b187c52b641aaeae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c994c5fdcb2173b187c52b641aaeae0">&#9670;&nbsp;</a></span>frag_ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRF24NetworkFrame.html">RF24NetworkFrame</a>* RF24Network::frag_ptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>ARDUINO platforms only</b></p>
<p>The <code>frag_ptr</code> is only used with Arduino (not RPi/Linux) and is mainly used for external data systems like RF24Ethernet. When a payload of type <a class="el" href="group__DEFINED__TYPES.html#gac6bbd2772e776d10ca7c5f3c7eddf982">EXTERNAL_DATA_TYPE</a> is received, and returned from <a class="el" href="classRF24Network.html#ad59983f89b09d17d7d9b0581f658a41c">update()</a>, the <code>frag_ptr</code> will always point to the starting memory location of the received frame. <br  />
This is used by external data systems (RF24Ethernet) to immediately copy the received data to a buffer, without using the user-cache.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structRF24NetworkFrame.html">RF24NetworkFrame</a></dd></dl>
<div class="fragment"><div class="line">uint8_t return_type = network.update();</div>
<div class="line"><span class="keywordflow">if</span>(return_type == <a class="code" href="group__DEFINED__TYPES.html#gac6bbd2772e776d10ca7c5f3c7eddf982">EXTERNAL_DATA_TYPE</a>) {</div>
<div class="line">    memcpy(&amp;myDataBuffer, network.frag_ptr-&gt;message_buffer, network.frag_ptr-&gt;message_size);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__DEFINED__TYPES_html_gac6bbd2772e776d10ca7c5f3c7eddf982"><div class="ttname"><a href="group__DEFINED__TYPES.html#gac6bbd2772e776d10ca7c5f3c7eddf982">EXTERNAL_DATA_TYPE</a></div><div class="ttdeci">#define EXTERNAL_DATA_TYPE</div><div class="ttdef"><b>Definition:</b> RF24Network.h:103</div></div>
</div><!-- fragment --><p> Linux devices (defined as <code>RF24_LINUX</code>) currently cache all payload types, and do not utilize <code>frag_ptr</code>. </p>

</div>
</div>
<a id="afb6b1d5c0fa3d982425f7a1f4fb48d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6b1d5c0fa3d982425f7a1f4fb48d13">&#9670;&nbsp;</a></span>returnSysMsgs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24Network::returnSysMsgs</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variable to determine whether <a class="el" href="classRF24Network.html#ad59983f89b09d17d7d9b0581f658a41c">update()</a> will return after the radio buffers have been emptied (DEFAULT), or whether to return immediately when (most) system types are received.</p>
<p>As an example, this is used with RF24Mesh to catch and handle system messages without loading them into the user cache.</p>
<p>The following reserved/system message types are handled automatically, and not returned.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">System Message Types <br  />
 (Not Returned)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__DEFINED__TYPES.html#ga25ad7c77b5ffa6acd7a5d9002a25a71b">NETWORK_ADDR_RESPONSE</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__DEFINED__TYPES.html#gac60baa80629bef34c13bd6a171f278c7">NETWORK_ACK</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__DEFINED__TYPES.html#gae678555396e5ea61506a0484cb2e0260">NETWORK_PING</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__DEFINED__TYPES.html#ga8cbda56553334074392866d4b8359388">NETWORK_POLL</a> <br  />
(With multicast enabled)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__DEFINED__TYPES.html#gadb43d169421055bc8a3e7da428da1c30">NETWORK_REQ_ADDRESS</a>   </td></tr>
</table>

</div>
</div>
<a id="a476806538919b167465181ab872e0cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476806538919b167465181ab872e0cad">&#9670;&nbsp;</a></span>networkFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24Network::networkFlags</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Network Flags allow control of data flow</p>
<p>Incoming Blocking: If the network user-cache is full, lets radio cache fill up. Radio ACKs are not sent when radio internal cache is full.<br  />
 This behaviour may seem to result in more failed sends, but the payloads would have otherwise been dropped due to the cache being full.<br  />
</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">FLAGS   </th><th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="RF24Network_8h.html#a00fc52e4f9f6e4716c365bf201163b7e">FLAG_FAST_FRAG</a>   </td><td class="markdownTableBodyNone">4 (bit 2 asserted)   </td><td class="markdownTableBodyNone">INTERNAL: Replaces the fastFragTransfer variable, and allows for faster transfers between directly connected nodes.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="RF24Network_8h.html#a4b3df085f3e9afddfa6d9647cd142c44">FLAG_NO_POLL</a>   </td><td class="markdownTableBodyNone">8 (bit 3 asserted)   </td><td class="markdownTableBodyNone">EXTERNAL/USER: Disables <a class="el" href="group__DEFINED__TYPES.html#ga8cbda56553334074392866d4b8359388">NETWORK_POLL</a> responses on a node-by-node basis.   </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Bit posistions 0 &amp; 1 in the <code>networkFlags</code> byte are no longer used as they once were during experimental development. </dd></dl>

</div>
</div>
<a id="a5b89e48e46eebb615b2ef152f057aca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b89e48e46eebb615b2ef152f057aca7">&#9670;&nbsp;</a></span>_multicast_level</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24Network::_multicast_level</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The current node's network level (used for multicast TX/RX-ing). </p><dl class="section see"><dt>See also</dt><dd>Use <a class="el" href="classRF24Network.html#a4fb7c61eee75d708a4ba20bb1caec54f">multicastLevel()</a> to adjust this when needed. </dd></dl>

</div>
</div>
<a id="a17017b584633bb969d004c4c43ca5c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17017b584633bb969d004c4c43ca5c82">&#9670;&nbsp;</a></span>node_address</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t RF24Network::node_address</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Logical node address of this unit, typically in range [0, 2925] (that's [0, 05555] in octal). </p><dl class="section note"><dt>Note</dt><dd>The values 0 represents the network master node. Additionally, the value 1 is occupied when using RF24Ethernet layer. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Nov 28 2021 23:36:51 for Newly Optimized RF24Network Layer by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
